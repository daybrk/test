package graphQL

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"log/slog"
	"test-task/internal/domain/user"
)

type UseCase interface {
	Enrichment(fio user.User) error
	DeleteUser(id int) error
	ModifyUser(enrichmentFio user.EnrichmentUser) error
}

type Resolver struct {
	useCase UseCase
	log     *slog.Logger
}

func NewUserResolver(useCase UseCase, log *slog.Logger) *Resolver {
	return &Resolver{useCase: useCase, log: log}
}

func (r *mutationResolver) AddUser(ctx context.Context, input User) (*Result, error) {
	r.log.Info("Начато обогащение и добавление пользователя в базу", slog.Any("user", input))

	err := r.useCase.Enrichment(user.User{
		Name:       input.Name,
		Surname:    input.Surname,
		Patronymic: input.Patronymic,
	})
	if err != nil {
		r.log.Error("Ошибка", slog.String("err", err.Error()))

		return nil, nil
	}
	return nil, nil
}

func (r *mutationResolver) DeleteUser(ctx context.Context, input DeleteUser) (*Result, error) {
	if input.ID == 0 {
		r.log.Error("ошибка в отправляемых данных id = 0")

		return nil, nil
	}

	err := r.useCase.DeleteUser(input.ID)
	if err != nil {
		r.log.Error("ошибка при удалении пользователя", slog.String("err", err.Error()))

		return nil, nil
	}
	return nil, nil
}

func (r *mutationResolver) ModifyUser(ctx context.Context, input ModifyUser) (*Result, error) {
	if input.ID == 0 {
		r.log.Error("ошибка в отправляемых данных id = 0")

		return nil, nil
	}

	err := r.useCase.ModifyUser(user.EnrichmentUser{
		Id:          input.ID,
		Name:        input.Name,
		Surname:     input.Surname,
		Patronymic:  input.Patronymic,
		Age:         input.Age,
		Gender:      input.Gender,
		Nationality: input.Nationality,
	})
	if err != nil {
		r.log.Error("Ошибка", slog.String("err", err.Error()))

		return nil, nil
	}

	r.log.Info("Получилось")

	return nil, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
